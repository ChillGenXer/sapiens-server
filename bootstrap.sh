#!/usr/bin/env bash
# Author: ChillGenXer (chillgenxer@gmail.com)
# Description: Initial setup and system functions.

# Set a trap to clear the screen when exiting
#trap shutdown_sequence EXIT

# Check if the script is being run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    local current_script=$(basename "${BASH_SOURCE[0]}")
    echo "The script ($current_script) is a library file, and not meant to be run directly. Run sapiens.sh only."
    logit "INFO" "Attempt to run $current_script directly detected.  Please use sapiens.sh for all operations."
    exit 1
fi


# A little generic yes/no prompt.
yesno() {
    local prompt="$1"
    local answer
    logit "DEBUG" "yesno() invoked with prompt: '$prompt'"

    # Loop until a valid response is received
    while true; do
        read -p "$prompt (y/n): " answer
        case "$answer" in
            [Yy]) return 0 ;;  # User responded 'yes'
            [Nn]) return 1 ;;  # User responded 'no'
            *) echo "Please answer y or n." ;;  # Invalid response
        esac
    done
}

# Logging function.
logit() {
    # Logs messages with a timestamp and severity to a specified log file.
    # Skips DEBUG messages if debug_mode is set to "off".
    # Parameters:
    #   $1 - severity (e.g., DEBUG, INFO, WARN, ERROR)
    #   $2 - message (log message string)
    # Usage:
    #   logit "ERROR" "Failed to start the server"

    local debug_mode="on"  # Set to "on" to enable debug logging, "off" to disable.
    
    local severity="$1"
    local message="$2"
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")  # Formats timestamp as 'Year-Month-Day Hour:Minute:Second'
    local valid_severities=("DEBUG" "INFO" "WARN" "ERROR")
    

    # Check if the log file variable is set
    if [ -z "$SAPSERVER_LOG" ]; then
        echo "Error: SAPSERVER_LOG is not set."
        exit 1
    fi

    # Check if the log file exists and create it if it does not
    if [ ! -f "$SAPSERVER_LOG" ]; then
        touch "$SAPSERVER_LOG"
    fi

    # Check if the severity is valid
    local is_valid_severity=false
    for valid_severity in "${valid_severities[@]}"; do
        if [[ "$severity" == "$valid_severity" ]]; then
            is_valid_severity=true
            break
        fi
    done

    if [ "$is_valid_severity" = false ]; then
        echo "Invalid severity level: $severity"
        exit 1
    fi

    # Check if debugging is off and severity is DEBUG, then skip logging
    if [[ "$debug_mode" == "off" && "$severity" == "DEBUG" ]]; then
        return 0
    fi

    # Append the log entry to the file
    echo "$timestamp [$severity]: $message" >> "$SAPSERVER_LOG"
}

#Generate a configuration file
create_config() {
    logit "DEBUG" "create_config initiated."
    # Refresh the Sapiens Version
    get_sapiens_version

    # Assemble the configuration file contents
    local config_content
    config_content+="#!/usr/bin/env bash\n\n"
    config_content+="# --------------------------------------------------------------------------------------\n"
    config_content+="# WARNING! This file is regenerated by the Sapiens Server Manager application. You\n"
    config_content+="# should not manually edit the values in this file, they will be overwritten. To change \n"
    config_content+="# configuration settings, please run sapiens.sh.\n"
    config_content+="# --------------------------------------------------------------------------------------\n\n"
    
    config_content+="# Script & Sapiens Version\n"
    config_content+="VERSION=\"0.5.0\"\n"
    config_content+="SAPIENS_VERSION=\"$SAPIENS_VERSION\"\n\n"

    config_content+="# Active Server World command line startup args\n"
    config_content+="WORLD_NAME=\"$WORLD_NAME\"\n"
    config_content+="WORLD_ID=\"$WORLD_ID\"\n"
    config_content+="UDP_PORT=\"$UDP_PORT\"\n"
    config_content+="HTTP_PORT=\"$HTTP_PORT\"\n"
    config_content+="ADVERTISE=\"$ADVERTISE\"\n"
    config_content+="PROVIDE_LOGS=\"$PROVIDE_LOGS\"\n\n"

    config_content+="# Values needed by start.sh\n"
    config_content+="SCRIPT_DIR=\"$SCRIPT_DIR\"\n"
    config_content+="GAME_DIR=\"$GAME_DIR\"\n"
    config_content+="SERVER_ID=\"$SERVER_ID\"\n\n"
    
    config_content+="# World Locations\n"
    config_content+="WORLDS_DIR=\"$WORLDS_DIR\"\n"
    config_content+="WORLD_DIR=\"$PLAYERS_DIR/$SERVER_ID/worlds/$WORLD_ID\"\n"
    config_content+="WORLD_CONFIG_LUA=\"$PLAYERS_DIR/$SERVER_ID/worlds/$WORLD_ID/config.lua\"\n"
    config_content+="WORLD_INFO=\"$PLAYERS_DIR/$SERVER_ID/worlds/$WORLD_ID/info.json\"\n\n"

    config_content+="# World Logs\n"
    config_content+="ENET_LOG=\"$PLAYERS_DIR/$SERVER_ID/worlds/$WORLD_ID/enetServerLog.log\"\n"
    config_content+="SERVERLOG_LOG=\"$PLAYERS_DIR/$SERVER_ID/worlds/$WORLD_ID/logs/serverLog.log\"\n"
    config_content+="WORLD_LOGS_DIR=\"$PLAYERS_DIR/$SERVER_ID/worlds/$WORLD_ID/logs\"\n"
    config_content+="LOG_BACKUP_DIR=\"$LOG_BACKUP_DIR\"\n"

    # Write the content of the variable to the config file
    logit "DEBUG" "$config_content"
    logit "INFO" "Writing the new configfile to $CONFIG_FILE"
    echo -e "$config_content" > "$CONFIG_FILE"

    # Check for errors in creating the file
    if [ $? -ne 0 ]; then
        logit "INFO" "Failed to create configuration file at $CONFIG_FILE"
        echo "Failed to create configuration file at $CONFIG_FILE"
        exit 1
    fi
}

# Checks to make sure logging directories are created
log_dir_check(){
    # Define the directory names
    directories=("$LOG_BACKUP_DIR" "$BACKUP_DIR")

    # Loop through each directory to check and create if necessary
    for dir in "${directories[@]}"; do
        if [ ! -e "$dir" ]; then
            # If the directory does not exist, create it
            logit "INFO" "Creating directory: $dir"
            mkdir "$dir"
        else
            logit "DEBUG" "Directory exists: $dir"
        fi
    done
}
